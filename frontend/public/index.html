<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VisLang - AI Reality</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; /* Prevent scroll on desktop */
            background-color: #020202; 
            font-family: 'Rajdhani', sans-serif; 
        }

        /* 3D Canvas Background */
        #canvas-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1; 
            background: radial-gradient(circle at center, #0a101f 0%, #000000 100%);
        }

        /* Hidden Video Input */
        #input-video { display: none; }

        /* --- CENTER OVERLAY (Title & Button) --- */
        .center-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            width: 100%;
            pointer-events: none; /* Let clicks pass */
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 6rem; /* Slightly smaller to fit layout */
            margin: 0;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 12px;
            text-shadow: 0 0 20px #00ffff, 0 0 50px #0088ff;
            animation: glitch-glow 4s infinite alternate;
        }

        h2 {
            font-size: 1.4rem;
            color: #dcdcdc;
            margin-top: 10px;
            letter-spacing: 5px;
            font-weight: 500;
        }

        .cta-container {
            margin-top: 40px;
            pointer-events: auto;
        }

        .btn-launch {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            padding: 16px 55px;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            border-radius: 50px;
            display: inline-block;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .btn-launch:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            transform: scale(1.05);
        }

        /* --- FOUR CORNER CARDS --- */
        .corner-card {
            position: absolute;
            z-index: 10;
            background: rgba(0, 10, 20, 0.7); /* Darker for readability */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 20px;
            width: 300px;
            border-radius: 12px;
            pointer-events: auto;
            transition: transform 0.3s, border-color 0.3s;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .corner-card:hover {
            border-color: #00ffff;
            transform: scale(1.02);
            background: rgba(0, 15, 30, 0.85);
        }

        /* Specific Positions */
        .top-left { top: 40px; left: 40px; border-left: 3px solid #00ffff; }
        .top-right { top: 40px; right: 40px; border-right: 3px solid #00ffff; text-align: right; }
        .bottom-left { bottom: 80px; left: 40px; border-left: 3px solid #00ffff; }
        .bottom-right { bottom: 80px; right: 40px; border-right: 3px solid #00ffff; text-align: right; }

        .corner-card h3 {
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            margin: 0 0 8px 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }
        
        /* Align icons for right-side cards */
        .top-right h3, .bottom-right h3 { justify-content: flex-end; }

        .corner-card p {
            color: #ccc; /* Much brighter than previous grey */
            font-size: 0.95rem;
            margin: 0;
            line-height: 1.5;
        }

        .card-icon { color: #00ffff; margin: 0 10px; font-size: 1.2em;}

        /* --- BOTTOM HINTS --- */
        .hints {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            z-index: 5;
            pointer-events: none;
        }
        .hint-icon { margin: 0 15px; display: inline-block; transition: color 0.3s; }
        .hint-active { color: #00ffff; text-shadow: 0 0 10px #00ffff; font-weight: bold; }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            z-index: 20;
            font-family: 'Orbitron', sans-serif;
            animation: pulse 1s infinite;
        }

        /* --- MOBILE OPTIMIZATION --- */
        @media (max-width: 900px) {
            body { overflow-y: auto; } /* Allow scrolling on phone */
            
            h1 { font-size: 3.5rem; letter-spacing: 5px; margin-top: 60px; }
            h2 { font-size: 1rem; letter-spacing: 2px; }

            .center-overlay {
                position: relative;
                top: 0; left: 0;
                transform: none;
                padding-bottom: 40px;
                height: auto;
            }

            #canvas-container {
                position: fixed; /* Keep canvas background fixed */
            }

            /* Stack cards vertically on mobile */
            .corner-card {
                position: relative;
                width: 85%;
                margin: 15px auto;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                bottom: auto !important;
                text-align: left !important; /* Reset right alignment */
                border-left: 3px solid #00ffff !important;
                border-right: 1px solid rgba(0,255,255,0.2) !important;
            }
            
            .corner-card h3 { justify-content: flex-start !important; }
            
            /* Hide hints on very small screens to save space */
            .hints { display: none; }
            
            .cta-container { margin-bottom: 20px; }
        }

        @keyframes glitch-glow {
            0% { text-shadow: 0 0 20px rgba(0,255,255,0.6); }
            100% { text-shadow: 0 0 40px rgba(0,255,255,0.9); }
        }
        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loading">Initializing Neural Interface...</div>
    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <div class="center-overlay">
        <h1>VisLang</h1>
        <h2>Real-Time Vision & Language Intelligence</h2>
        
        <div class="cta-container">
            <a href="dashboard.html" class="btn-launch">Enter Studio</a>
        </div>
    </div>

    <div class="corner-card top-left">
        <h3><span class="card-icon">‚óà</span> Object Intelligence</h3>
        <p>Real-time detection using <strong>YOLOv8</strong>. Instantly identify and track objects in your environment with millisecond latency.</p>
    </div>

    <div class="corner-card top-right">
        <h3>Vision Chat <span class="card-icon">üí¨</span></h3>
        <p>Conversational AI that "sees" what you see. Ask questions about the scene and get context-aware answers instantly.</p>
    </div>

    <div class="corner-card bottom-left">
        <h3><span class="card-icon">üé•</span> Video Analytics</h3>
        <p>Upload video feeds for automated detection and summarization. Get concise insights from long-form footage.</p>
    </div>

    <div class="corner-card bottom-right">
        <h3>SAM Segmentation <span class="card-icon">‚úÇÔ∏è</span></h3>
        <p>Powered by the <strong>Segment Anything Model</strong>. Isolate complex objects from backgrounds with pixel-perfect precision.</p>
    </div>

    <div class="hints">
        <span class="hint-icon" id="h-color">üëã Move: Color</span>
        <span class="hint-icon" id="h-flower">‚úåÔ∏è Peace: Flower</span>
        <span class="hint-icon" id="h-camera">ü§è Pinch: Camera</span>
        <span class="hint-icon" id="h-planet">‚úä Fist: Planet</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 5500; 
        const PARTICLE_SIZE = 0.35;
        let currentShape = 'sphere';
        
        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45; // Moved back slightly to account for UI elements

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const r = 18 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);

            targetPositions[i3] = positions[i3];
            targetPositions[i3+1] = positions[i3+1];
            targetPositions[i3+2] = positions[i3+2];

            if(Math.random() > 0.5) {
                colorObj.setHSL(0.55, 0.9, 0.6); 
            } else {
                colorObj.setHSL(0.8, 0.9, 0.6);
            }
            colors[i3] = colorObj.r;
            colors[i3+1] = colorObj.g;
            colors[i3+2] = colorObj.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8,
            map: getGlowTexture() 
        });

        function getGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.Texture(canvas);
        }
        material.map.needsUpdate = true;

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE LOGIC ---
        function setTargetShape(shapeType) {
            currentShape = shapeType;
            const scale = 14; 
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (shapeType === 'sphere') {
                    const r = scale * 1.2 * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (shapeType === 'camera') {
                    const p = Math.random();
                    if (p < 0.6) { 
                        x = (Math.random() - 0.5) * 20;
                        y = (Math.random() - 0.5) * 12;
                        z = (Math.random() - 0.5) * 6;
                    } else if (p < 0.9) { 
                        const r = Math.random() * 5.5;
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta);
                        y = r * Math.sin(theta);
                        z = 3 + Math.random() * 6;
                    } else { 
                        x = 5 + (Math.random() - 0.5) * 4;
                        y = 6 + Math.random() * 2;
                        z = (Math.random() - 0.5) * 4;
                    }
                } 
                else if (shapeType === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = scale * (1 + 0.5 * Math.sin(4 * theta) * Math.sin(4 * phi));
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi) * 0.5;
                } 
                else if (shapeType === 'saturn') {
                    if (Math.random() > 0.45) { 
                        const angle = Math.random() * Math.PI * 2;
                        const dist = (scale * 1.4) + Math.random() * (scale * 0.8);
                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        y = (Math.random() - 0.5) * 1.5;
                    } else { 
                        const r = scale * 0.9 * Math.cbrt(Math.random());
                        const theta = Math.random() * 2 * Math.PI;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                }
                targetPositions[i3] = x;
                targetPositions[i3+1] = y;
                targetPositions[i3+2] = z;
            }
        }

        // --- HAND TRACKING & UI FEEDBACK ---
        const videoElement = document.getElementById('input-video');
        
        function activateHint(id) {
            document.querySelectorAll('.hint-icon').forEach(el => el.classList.remove('hint-active'));
            const el = document.getElementById(id);
            if(el) el.classList.add('hint-active');
        }

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const index = hand[8];
                const thumb = hand[4];
                const middle = hand[12];
                const wrist = hand[0];

                const hueShift = Math.abs(1 - index.x); 
                particles.material.color.setHSL(hueShift, 0.9, 0.6);
                activateHint('h-color');
                
                const rotX = (index.y - 0.5) * 2;
                const rotY = (index.x - 0.5) * 2;
                particles.rotation.x += (rotX - particles.rotation.x) * 0.08;
                particles.rotation.y += (rotY - particles.rotation.y) * 0.08;

                const dx = index.x - thumb.x;
                const dy = index.y - thumb.y;
                const distPinch = Math.sqrt(dx*dx + dy*dy);
                const isFist = (middle.y > wrist.y - 0.05);

                if (isFist) {
                    if (currentShape !== 'saturn') { setTargetShape('saturn'); activateHint('h-planet'); }
                } else if (distPinch < 0.05) {
                    if (currentShape !== 'camera') { setTargetShape('camera'); activateHint('h-camera'); }
                } else if (Math.abs(index.x - middle.x) > 0.12) { 
                    if (currentShape !== 'flower') { setTargetShape('flower'); activateHint('h-flower'); }
                } else {
                    if (currentShape !== 'sphere' && Math.random() > 0.95) setTargetShape('sphere');
                }
            } else {
                const time = Date.now() * 0.0005;
                particles.rotation.y += 0.003;
                particles.material.color.setHSL(0.6 + Math.sin(time) * 0.1, 0.8, 0.6);
                document.querySelectorAll('.hint-icon').forEach(el => el.classList.remove('hint-active'));
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = Date.now() * 0.001;
            
            const posAttr = geometry.attributes.position;
            const speed = 3.5 * delta;

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                posAttr.array[i] += (targetPositions[i] - posAttr.array[i]) * speed;
                if (currentShape === 'sphere') {
                    const noise = Math.sin(time + posAttr.array[i]*0.5) * 0.02;
                    posAttr.array[i] += noise;
                }
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>